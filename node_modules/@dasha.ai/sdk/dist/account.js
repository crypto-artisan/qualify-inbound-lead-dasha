"use strict";
/**
 * Stored account management.
 *
 * A number of account records can be stored into a platform-specific storage.
 * One of them can be marked as {@link getCurrentAccountName | current},
 * which will cause it to be used as a default account for methods that need one.
 *
 * In Node.js, you can manage stored accounts using the [Dasha CLI].
 *
 * [Dasha CLI]: https://npmjs.com/@dasha.ai/cli
 *
 * @module
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBaseHttpUrl = exports.anonymizeAccount = exports._getEffectiveAccount = exports.setCurrentAccountName = exports.getCurrentAccountName = exports.deleteAccount = exports.renameAccount = exports.setAccount = exports.getAccount = exports.listAccounts = void 0;
const env_paths_1 = require("env-paths");
const json_1 = require("./json");
const log_1 = require("./log");
const errors = require("./errors");
const defaultAccountConfig = {
    accounts: {},
    currentAccount: undefined,
};
function validateAccountConfig(log, value) {
    var _a;
    if (!json_1.AccountConfig.validate(value)) {
        log_1.logAndThrow(log, new errors.InternalError((_a = json_1.AccountConfig.validate.errors) === null || _a === void 0 ? void 0 : _a.join("\n")));
    }
}
function parseJson(log, content) {
    try {
        return JSON.parse(content);
    }
    catch (error) {
        log_1.logAndThrow(log, new errors.InternalError(error.message, error));
    }
}
function writeAccountConfig(log, config) {
    return __awaiter(this, void 0, void 0, function* () {
        validateAccountConfig(log, config);
        const configContent = JSON.stringify(config, undefined, 2);
        const fs = yield Promise.resolve().then(() => require("fs")).catch(() => undefined);
        const path = yield Promise.resolve().then(() => require("path")).catch(() => undefined);
        if (fs !== undefined && path !== undefined) {
            // we are in node
            const configDir = env_paths_1.default("dasha.ai", { suffix: "" }).config;
            const configPath = path.join(configDir, "accounts.json");
            try {
                yield fs.promises.mkdir(configDir, { recursive: true });
                yield fs.promises.writeFile(configPath, configContent);
            }
            catch (error) {
                throw new errors.FileSystemError(error);
            }
            return;
        }
        const sessionStorage = globalThis.sessionStorage;
        if (sessionStorage !== undefined) {
            // we are in a browser
            sessionStorage.setItem("@dasha.ai/sdk:accounts", configContent);
            return;
        }
        // where the hell are we?
        throw new errors.NotImplementedError();
    });
}
function readAccountConfig(log) {
    return __awaiter(this, void 0, void 0, function* () {
        const fs = yield Promise.resolve().then(() => require("fs")).catch(() => undefined);
        const path = yield Promise.resolve().then(() => require("path")).catch(() => undefined);
        if (fs !== undefined && path !== undefined) {
            // we are in node
            const configDir = env_paths_1.default("dasha.ai", { suffix: "" }).config;
            const configPath = path.join(configDir, "accounts.json");
            let configContent;
            try {
                configContent = yield fs.promises.readFile(configPath, { encoding: "utf-8" });
            }
            catch (error) {
                if (error.code === "ENOENT") {
                    // config not found; creating
                    yield writeAccountConfig(log, defaultAccountConfig);
                    return defaultAccountConfig;
                }
                log_1.logAndThrow(log, new errors.FileSystemError(error));
            }
            const config = parseJson(log, configContent);
            validateAccountConfig(log, config);
            return config;
        }
        const sessionStorage = globalThis.sessionStorage;
        if (sessionStorage !== undefined) {
            // we are in a browser
            const configContent = sessionStorage.getItem("@dasha.ai/sdk:accounts");
            if (configContent === null) {
                // config not found; creating
                yield writeAccountConfig(log, defaultAccountConfig);
                return defaultAccountConfig;
            }
            const config = parseJson(log, configContent);
            validateAccountConfig(log, config);
            return config;
        }
        // where the hell are we?
        throw new errors.NotImplementedError();
    });
}
/**
 * List all stored accounts.
 *
 * @returns a dictionary object storing accounts by their name
 */
function listAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        return config.accounts;
    });
}
exports.listAccounts = listAccounts;
/**
 * Get an account by its name. Throws if no account was found.
 */
function getAccount(name) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        const account = config.accounts[name];
        if (account === undefined) {
            log_1.logAndThrow(log, new errors.AccountNotFoundError(name));
        }
        return account;
    });
}
exports.getAccount = getAccount;
/**
 * Store an account under a name.
 *
 * @param options.overwrite if true, does not throw if the name is taken
 */
function setAccount(name, account, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        if (!(options === null || options === void 0 ? void 0 : options.overwrite) && name in config.accounts) {
            throw new errors.AccountExistsError(name);
        }
        config.accounts[name] = account;
        yield writeAccountConfig(log, config);
    });
}
exports.setAccount = setAccount;
/**
 * Rename a stored account.
 *
 * @param options.overwrite if true, does not throw if the new name is taken.
 */
function renameAccount(oldName, newName, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        if (!(options === null || options === void 0 ? void 0 : options.overwrite) && newName in config.accounts) {
            log_1.logAndThrow(log, new errors.AccountExistsError(newName));
        }
        config.accounts[newName] = config.accounts[oldName];
        delete config.accounts[oldName];
        if (config.currentAccount === oldName)
            config.currentAccount = newName;
        yield writeAccountConfig(log, config);
    });
}
exports.renameAccount = renameAccount;
/**
 * Delete a stored account.
 *
 * @param options.quiet if true, does not throw if no account was found
 */
function deleteAccount(name, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        if (!(options === null || options === void 0 ? void 0 : options.quiet) && !(name in config.accounts)) {
            throw new errors.AccountNotFoundError(name);
        }
        delete config.accounts[name];
        if (config.currentAccount === name)
            delete config.currentAccount;
        yield writeAccountConfig(log, config);
    });
}
exports.deleteAccount = deleteAccount;
/**
 * Get the name of a stored account that is marked as current, or `undefined` if no one is.
 */
function getCurrentAccountName() {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        return config.currentAccount;
    });
}
exports.getCurrentAccountName = getCurrentAccountName;
/**
 * Mark a stored account as current. Pass `undefined` to unset a current account altogether.
 */
function setCurrentAccountName(name) {
    return __awaiter(this, void 0, void 0, function* () {
        const log = log_1.log.child({ label: "accounts" });
        const config = yield readAccountConfig(log);
        if (name !== undefined && !(name in config.accounts)) {
            throw new errors.AccountNotFoundError(name);
        }
        config.currentAccount = name;
        yield writeAccountConfig(log, config);
    });
}
exports.setCurrentAccountName = setCurrentAccountName;
/** @internal */
function _getEffectiveAccount(options) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const log = (_a = options === null || options === void 0 ? void 0 : options._log) !== null && _a !== void 0 ? _a : log_1.log.child({ label: "accounts" });
        // if set, env vars override the account config
        if (process !== undefined) {
            const apiKey = process.env["DASHA_APIKEY"];
            const server = (_b = process.env["DASHA_SERVER"]) !== null && _b !== void 0 ? _b : "app.us.dasha.ai";
            const insecure = Boolean(process.env["DASHA_INSECURE"] === "1");
            if (apiKey !== undefined) {
                log.info("using the API key from environment variables");
                return { server, apiKey, insecure };
            }
        }
        const config = yield readAccountConfig(log);
        const currentAccountName = config.currentAccount;
        if (currentAccountName === undefined) {
            log_1.logAndThrow(log, new errors.Error("no account is set as current; did you forget to `dasha account login`?"));
        }
        const account = config.accounts[currentAccountName];
        if (account === undefined) {
            throw new errors.InternalError("invalid current account name");
        }
        return account;
    });
}
exports._getEffectiveAccount = _getEffectiveAccount;
/** @internal */
function anonymizeAccount(account) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { apiKey: _ } = account, rest = __rest(account, ["apiKey"]);
    return rest;
}
exports.anonymizeAccount = anonymizeAccount;
/** @internal */
function getBaseHttpUrl(account) {
    return (account.insecure ? "http://" : "https://") + account.server;
}
exports.getBaseHttpUrl = getBaseHttpUrl;
//# sourceMappingURL=account.js.map