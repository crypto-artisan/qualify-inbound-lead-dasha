import EventEmitter = require("eventemitter3");
import * as errors from "./errors";
import { Conversation } from "./conversation";
/**
 * @see {@link ConversationQueue}
 */
export interface QueuedConversationInfo {
    sip?: {
        fromUser: string;
        fromDomain: string;
        toUser: string;
        toDomain: string;
    };
}
/**
 * Manages planned conversations.
 *
 * A conversation may be _enqueued_, that is, planned to execute in a specific time frame.
 * When the conversation is to be executed, a `"ready"` event is fired on this object,
 * that gets passed a {@link Conversation} object to populate its input and run.
 *
 * The queue is stored on the Dasha platform. To associate an enqueued conversation
 * with its data, each conversation is assigned a _key_.
 *
 * @example running enqueued conversations
 * ```typescript
 * application.queue.on("ready", async (key, conversation) => {
 *   conversation.input = getInput(key);
 *   const result = await conversation.execute();
 * });
 * ```
 *
 * Sometimes, the conversation can be removed from the queue by the Dasha platform itself.
 * In that case, a `"rejected"` event is fired.
 *
 * @example conversation rejection
 * ```typescript
 * application.queue.on("rejected", (key, error) => {
 *   console.log(`conversation with key ${key} was rejected`, error);
 * });
 * ```
 *
 * There is an important caveat with the incoming SIP conversations.
 * They get placed in the queue automatically, by the Dasha platform itself.
 * To discern them from the manually-enqueued conversations, and to get the additional
 * SIP info (e.g. the SIP user and domain of the conversation partner),
 * the `"ready"` event has an extra argument of type {@link QueuedConversationInfo}.
 *
 * @example using SIP data in a conversation
 * ```typescript
 * application.queue.on("ready", (key, conversation, info) => {
 *   assert(info.sip !== undefined);
 *   conversation.input.from = `${info.fromUser}@${info.fromDomain}`;
 *   await conversation.execute();
 * });
 * ```
 */
export declare class ConversationQueue<TInput extends Record<string, unknown>, TOutput extends Record<string, unknown>> extends EventEmitter<{
    error: [error: errors.Error];
    ready: [key: string, conv: Conversation<TInput, TOutput>, info: QueuedConversationInfo];
    timeout: [key: string];
    rejected: [key: string, error: errors.ConversationRejectedError];
}> {
    private _log;
    private _application;
    private _ignoredJobKeys;
    private _activeConversationsByJobKey;
    private _isDisposed;
    /**
     * Push a new conversation into the queue.
     *
     * @param key a conversation key that can be used to associate data
     * @param options.after the earliest point in time the conversation can run at
     * @param options.before the latest point in time the conversation can run at
     *
     * @example enqueue a conversation to within an hour
     * ```typescript
     * application.queue.push("key", {
     *   after: new Date(),
     *   before: new Date(Date.now() + 60 * 60 * 1000)
     * });
     * ```
     */
    push(key: string, options?: {
        after?: Date;
        before?: Date;
        priority?: number;
    }): Promise<void>;
    private _handleJobTimedOut;
    private _handleJobRejected;
    private _handleJobStarting;
}
